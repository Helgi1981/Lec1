# Округление чисел

"""
a = 5.678945
b = 6.5674875
print(a*b) # Выводится слишком много знаков после запятой
"""

"""
a = 5.678945
b = 6.5674875
print(round(a*b, 3)) # Оставляем три знака после запятой
"""

# Сокращенные операции присваивания

"""
Помните в C# внутри цикла for мы писали i++. Это было сокращение
от i = i + 1. Посмотри как можно сокращать операторы
присваивания в Python
iter = 2
iter += 3 # iter = iter + 3
iter -= 4 # iter = iter - 4
iter *= 5 # iter = iter * 5
iter /= 5 # iter = iter / 5
iter //= 5 # iter = iter // 5
iter %= 5 # iter = iter % 5
iter **= 5 # iter = iter ** 5
"""

# Логические операции

"""
Знак операции                      Операция
>                                  Больше
>=                                 Больше или равно
<                                  Меньше
<=                                 Меньше или равно
==                                 Равно (проверяет, равны ли числа)
!=                                 Не равно (проверяет, не равны ли значения)
not                                Не (отрицание)
and                                И (конъюнкция)
or                                 Или (дизъюнкция)
"""

# Сравнение в Python

"""
В Python мы можем выполнять следующие сравнения. Результатом
чего будет либо True, либо False
a = 1 > 4
print(a) # False
# —------------------------------------
a = 1 < 4 and 5 > 2
print(a) # True
# —------------------------------------
a = 1 == 2
print(a) # False
# —------------------------------------
a = 1 != 2
print(a) # True

Можно сравнивать не только числовые значения, но и строки:
a = 'qwe'
b = 'qwe'
print(a == b) # True

В Python можно использовать тройные и даже четверные
неравенства:
a = 1 < 3 < 5 < 10
print (a) # True
"""

# Условия в Python

"""
Пример оформления программного кода с операторами ветвления:
if condition:
    # operator 1
    # operator 2
    # ...
    # operator n
else:
    # operator n + 1
    # operator n + 2
    # ...
    # operator n + m

Ещё один вариант использования операторов else-if → в связке с elif
(else if)

Проверяем первое условие, если оно не выполняется, проверяем
второе и так далее. Как только будет найдено верное условие, все
остальные будут игнорироваться.

if condition1:
    # operator
elif condition2:
    # operator
elif condition3:
    # operator
else:
    # operator
"""

# Сложные условия

"""
Сложные условия создаются с помощью логических операторов, таких как: and, or, not

if condition1 and condition2: # выполнится, когда оба условия окажутся верными
    # operator
if condition3 or condition4: # выполнится, когда хотя бы одно из условий окажется верным
    # operator
"""

# Цикл While

"""
Цикл позволяет выполнить блок кода, пока условие является верным.

while condition:                 n = 423
 # operator 1                    summa = 0
 # operator 2                    while n > 0:
    # ...                              x = n % 10
    # operator n                       summa =
                                 summa + x
                                       n = n // 10
                                 print(summa) # 9
"""

"""
n = 423
summa = 0
while n > 0:
    x = n % 10 
    summa = summa + x
    n = n // 10
print(summa) 
"""

# Управляющие конструкции: while-else

"""
while condition:
    # operator 1
    # operator 2
    # ...
    # operator n
else:
    # operator n + 1
    # operator n + 2
    # ...
    # operator n + m

Блок else выполняется, когда основное тело цикла перестает работать самостоятельно. А
разве кто-то может прекратить работу цикла? Если мы вспомним C#, то да и это конструкция
break.
"""

# Внутри Python она также существует и используется точно также. Пример:

"""
i = 0
while i < 5:
    if i == 3:
        break
    i = i + 1
else:
    print('Пожалуй')
    print('хватит )')
print(i)
"""

# Пример программного кода без использования break:

"""
n = 423
summa = 0
while n > 0:
    x = n % 10
    summa = summa + x
    n = n // 10
else:
    print('Пожалуй')
    print('хватит )')
print(summa)
"""
"""
После того, как мы с Вами обговорили оператор break и цикл while, стоит рассказать почему
не стоит использовать break и как в этом случае нам поможет Булевский тип данных?
Давайте разбираться. break отличная конструкция, которую нельзя не использовать в
некоторых алгоритмах, но break не функциональный стиль программирования. В ООП нет
ничего, что предполагает break внутри метода-плохая идея, так как может произойти
путаница. На замену break отлично подходит метод флажка.
"""

# Задача
# Пользователь вводит число, необходимо найти минимальный делитель данного числа
# Решение:

"""
n = int(input())
flag = True
i = 2
while flag:
    if n % i == 0: # если остаток при делении числа n на i равен 0
        flag = False
        print(i)
    elif i > n // 2: # делить числа не может превышать введенное число, деленное на 2
        print(n)
        flag = False
    i += 1
"""
"""
Данный алгоритм будет работать до тех пор, пока не найдется минимальный делитель
введенного числа. Когда будет найден первый делитель цикл остановит свою работу, так как
условие, которое находится внутри станет ложным(False)
"""

# Цикл for, функция range()

# В Python цикл for в основном используется для перебора значений
# Пример использования цикла for:

"""
for i in enumeration:
    # operator 1
    # operator 2
    # ...
    # operator n

for i in 1, -2, 3, 14, 5:
    print(i)
# 1 -2 3 15 5

● Range выдает значения из диапазона с шагом 1.
● Если указано только одно число — от 0 до заданного числа.
● Если нужен другой шаг, третьим аргументов можно задать приращение.

r = range(5) # 0 1 2 3 4
r = range(2, 5) # 2 3 4
r = range(-5, 0) # ----
r = range(1, 10, 2) # 1 3 5 7
r = range(100, 0, -20) # 100 80 60 40 20
r = range(100, 0, -20) # range(100, 0, -20)
for i in r:
    print(i)
# 100 80 60 40 20
"""

# Можно использовать цикл for() и со строками, так как у строк есть нумерация, такая же как и
# у массивов, начинается с 0:

"""
for i in 'qwerty':
    print(i)

 # q
 # w
 # e
 # r
 # t
 # y
"""
"""
a = 'qwerty'
print(a[2])
"""

# Можно использовать вложенные циклы:

"""
line = ""
for i in range(5):
    line = ""
    for j in range(5):
        line += "*"
    print(line)
"""
"""
Программный код выведет 5 строк “******”. Сначала запускается внешний цикл с i(счетчик
цикла). После этого запускается внутренний цикл с j(счетчик цикла). После того как
внутренний цикл завершил свою работу, переменная line = “*****” и выводится на экран,
далее опять повторяется внешний цикл и так 5 раз.
"""

# Немного о строках

"""
Возникают ситуации, когда в некоторых задачах необходимо поработать со строкой,
которую ввел пользователь. Например: необходимо сделать все буквы маленькими, или
поменять все буквы “ё” на “е”.
"""

# text = 'СъЕШЬ ещё этих МяГкИх французских булок'
# print(len(text)) # 39
# print('ещё' in text) # True
# print(text.lower()) # съешь ещё этих мягких французских булок
# print(text.upper()) # СЪЕШЬ ЕЩЁ ЭТИХ МЯГКИХ ФРАНЦУЗСКИХ БУЛОК
# print(text.replace('ещё','ЕЩЁ')) # СъЕШЬ ЕЩЁ этих МяГкИх французских булок

# Срезы

"""
● Мы представляем строку в виде массива символов. Значит мы можем обращаться к
элементам по индексам.
● Отрицательное число в индексе — счёт с конца строки
"""
"""
text = 'съешь ещё этих мягких французских булок'
print(text[0]) # c
print(text[1]) # ъ
print(text[len(text)-1]) # к
print(text[-1]) # к
print(text[-5]) # б
print(text[:]) # съешь ещё этих мягких французских булок
print(text[:2]) # съ
print(text[len(text)-2:]) # ок
print(text[2:9]) # ешь ещё
print(text[6:-18]) # ещё этих мягких
print(text[0:len(text):6]) # сеикакл
print(text[::6]) # сеикакл
text = text[2:9] + text[-5] + text[:2] # ...
"""
